<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Chatbot | CodingNepal</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@32,400,0,0" />
    <style>
/* Import Google Font - Poppins */
@import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap");
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
}
:root {
  /* Dark theme colors */
  --text-color: #edf3ff;
  --subheading-color: #97a7ca;
  --placeholder-color: #c3cdde;
  --primary-color: #101623;
  --secondary-color: #283045;
  --secondary-hover-color: #333e58;
  --scrollbar-color: #626a7f;
}
body.light-theme {
  /* Light theme colors */
  --text-color: #090c13;
  --subheading-color: #7b8cae;
  --placeholder-color: #606982;
  --primary-color: #f3f7ff;
  --secondary-color: #dce6f9;
  --secondary-hover-color: #d2ddf2;
  --scrollbar-color: #a2aac2;
}
body {
  color: var(--text-color);
  background: var(--primary-color);
}
.container {
  overflow-y: auto;
  padding: 32px 0 60px;
  height: calc(100vh - 127px);
  scrollbar-color: var(--scrollbar-color) transparent;
}
.container :where(.app-header, .suggestions, .message, .prompt-wrapper) {
  position: relative;
  margin: 0 auto;
  width: 100%;
  padding: 0 20px;
  max-width: 990px;
}
.container .app-header {
  margin-top: 3vh;
}
.app-header .heading {
  width: fit-content;
  font-size: 3rem;
  background: linear-gradient(to right, #1d7efd, #8f6fff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.app-header .sub-heading {
  font-size: 2.6rem;
  margin-top: -5px;
  color: var(--subheading-color);
}
.container .suggestions {
  width: 100%;
  list-style: none;
  display: flex;
  gap: 15px;
  margin-top: 9.5vh;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  scrollbar-width: none;
}
body.chats-active .container :where(.app-header, .suggestions) {
  display: none;
}
.suggestions .suggestions-item {
  cursor: pointer;
  padding: 18px;
  width: 228px;
  flex-shrink: 0;
  display: flex;
  scroll-snap-align: center;
  flex-direction: column;
  align-items: flex-end;
  border-radius: 12px;
  justify-content: space-between;
  background: var(--secondary-color);
  transition: 0.3s ease;
}
.suggestions .suggestions-item:hover {
  background: var(--secondary-hover-color);
}
.suggestions .suggestions-item .text {
  font-size: 1.1rem;
}
.suggestions .suggestions-item .icon {
  width: 45px;
  height: 45px;
  display: flex;
  font-size: 1.4rem;
  margin-top: 35px;
  align-self: flex-end;
  align-items: center;
  border-radius: 50%;
  justify-content: center;
  color: #1d7efd;
  background: var(--primary-color);
}
.suggestions .suggestions-item:nth-child(2) .icon {
  color: #28a745;
}
.suggestions .suggestions-item:nth-child(3) .icon {
  color: #ffc107;
}
.suggestions .suggestions-item:nth-child(4) .icon {
  color: #6f42c1;
}
.container .chats-container {
  display: flex;
  gap: 20px;
  flex-direction: column;
}
.chats-container .message {
  display: flex;
  gap: 11px;
  align-items: center;
}
.chats-container .message .avatar {
  width: 43px;
  height: 43px;
  flex-shrink: 0;
  align-self: flex-start;
  border-radius: 50%;
  padding: 6px;
  margin-right: -7px;
  background: var(--secondary-color);
  border: 1px solid var(--secondary-hover-color);
}
.chats-container .message.loading .avatar {
  animation: rotate 3s linear infinite;
}
@keyframes rotate {
  100% {
    transform: rotate(360deg);
  }
}
.chats-container .message .message-text {
  padding: 3px 16px;
  word-wrap: break-word;
  white-space: pre-line;
}
.chats-container .bot-message {
  margin: 9px auto;
}
.chats-container .user-message {
  flex-direction: column;
  align-items: flex-end;
}
.chats-container .user-message .message-text {
  padding: 12px 16px;
  max-width: 75%;
  background: var(--secondary-color);
  border-radius: 13px 13px 3px 13px;
}
.chats-container .user-message .img-attachment {
  margin-top: -7px;
  width: 50%;
  border-radius: 13px 3px 13px 13px;
}
.chats-container .user-message .file-attachment {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: 10px;
  margin-top: -7px;
  border-radius: 13px 3px 13px 13px;
  background: var(--secondary-color);
}
.chats-container .user-message .file-attachment span {
  color: #1d7efd;
}
.container .prompt-container {
  position: fixed;
  width: 100%;
  left: 0;
  bottom: 0;
  padding: 16px 0;
  background: var(--primary-color);
}
.prompt-container :where(.prompt-wrapper, .prompt-form, .prompt-actions) {
  display: flex;
  gap: 12px;
  height: 56px;
  align-items: center;
}
.prompt-container .prompt-form {
  height: 100%;
  width: 100%;
  border-radius: 130px;
  background: var(--secondary-color);
}
.prompt-form .prompt-input {
  width: 100%;
  height: 100%;
  background: none;
  outline: none;
  border: none;
  font-size: 1rem;
  color: var(--text-color);
  padding-left: 24px;
}
.prompt-form .prompt-input::placeholder {
  color: var(--placeholder-color);
}
.prompt-wrapper button {
  width: 56px;
  height: 100%;
  flex-shrink: 0;
  cursor: pointer;
  border-radius: 50%;
  font-size: 1.4rem;
  border: none;
  color: var(--text-color);
  background: var(--secondary-color);
  transition: 0.3s ease;
}
.prompt-wrapper :is(button:hover, #cancel-file-btn, .file-icon) {
  background: var(--secondary-hover-color);
}
.prompt-form .prompt-actions {
  gap: 5px;
  margin-right: 7px;
}
.prompt-wrapper .prompt-form :where(.file-upload-wrapper, button, img) {
  position: relative;
  height: 45px;
  width: 45px;
}
.prompt-form .prompt-actions #send-prompt-btn {
  color: #fff;
  display: none;
  background: #1d7efd;
}
/* Show send button when input has text OR when a file is attached */
.prompt-form .prompt-input:valid~.prompt-actions #send-prompt-btn,
.prompt-form .file-upload-wrapper.active~.prompt-actions #send-prompt-btn {
  display: block;
}
.prompt-form #send-prompt-btn:hover {
  background: #0264e3;
}
.prompt-form .file-upload-wrapper :where(button, img) {
  display: none;
  border-radius: 50%;
  object-fit: cover;
  position: absolute;
}
.prompt-form .file-upload-wrapper.active #add-file-btn {
  display: none;
}
.prompt-form .file-upload-wrapper #add-file-btn,
.prompt-form .file-upload-wrapper.active.img-attached img,
.prompt-form .file-upload-wrapper.active.file-attached .file-icon,
.prompt-form .file-upload-wrapper.active:hover #cancel-file-btn {
  display: block;
}
.prompt-form :is(#stop-response-btn:hover, #cancel-file-btn) {
  color: #d62939;
}
.prompt-wrapper .prompt-form .file-icon {
  color: #1d7efd;
}
.prompt-form #stop-response-btn,
body.bot-responding .prompt-form .file-upload-wrapper {
  display: none;
}
body.bot-responding .prompt-form #stop-response-btn {
  display: block;
}
.prompt-container .disclaimer-text {
  font-size: 0.9rem;
  text-align: center;
  padding: 16px 20px 0;
  color: var(--placeholder-color);
}
/* Responsive media query code for small screens */
@media (max-width: 768px) {
  .container {
    padding: 20px 0 100px;
  }
  
  /* EVO OVO SAM DODAO */
  .suggestions {
    display: none;
  }
  /* KRAJ DODATKA */

  .app-header :is(.heading, .sub-heading) {
    font-size: 2rem;
    line-height: 1.4;
  }
  .app-header .sub-heading {
    font-size: 1.7rem;
  }
  .container .chats-container {
    gap: 15px;
  }
  .chats-container .bot-message {
    margin: 4px auto;
  }
  .prompt-container :where(.prompt-wrapper, .prompt-form, .prompt-actions) {
    gap: 8px;
    height: 53px;
  }
  .prompt-container button {
    width: 53px;
  }
  .prompt-form :is(.file-upload-wrapper, button, img) {
    height: 42px;
    width: 42px;
  }
  .prompt-form .prompt-input {
    padding-left: 20px;
  }
  .prompt-form .file-upload-wrapper.active #cancel-file-btn {
    opacity: 0;
  }
  .prompt-wrapper.hide-controls :where(#theme-toggle-btn, #delete-chats-btn) {
    display: none;
  }
}
</style>
  </head>
  <body>
    <div class="container">
      <header class="app-header">
        <h1 class="heading">Hello, there</h1>
        <h4 class="sub-heading">How can I help you today?</h4>
      </header>
      <ul class="suggestions">
        <li class="suggestions-item">
          <p class="text">Design a home office setup for remote work under $500.</p>
          <span class="icon material-symbols-rounded">draw</span>
        </li>
        <li class="suggestions-item">
          <p class="text">How can I level up my web development expertise in 2025?</p>
          <span class="icon material-symbols-rounded">lightbulb</span>
        </li>
        <li class="suggestions-item">
          <p class="text">Suggest some useful tools for debugging JavaScript code.</p>
          <span class="icon material-symbols-rounded">explore</span>
        </li>
        <li class="suggestions-item">
          <p class="text">Create a React JS component for the simple todo list app.</p>
          <span class="icon material-symbols-rounded">code_blocks</span>
        </li>
      </ul>
      <div class="chats-container"></div>
      <div class="prompt-container">
        <div class="prompt-wrapper">
          <form action="#" class="prompt-form">
            <input type="text" placeholder="Ask Gemini" class="prompt-input" required />
            <div class="prompt-actions">
              <div class="file-upload-wrapper">
                <img src="#" class="file-preview" />
                <input id="file-input" type="file" accept="image/*, .pdf, .txt, .csv" hidden />
                <button type="button" class="file-icon material-symbols-rounded">description</button>
                <button id="cancel-file-btn" type="button" class="material-symbols-rounded">close</button>
                <button id="add-file-btn" type="button" class="material-symbols-rounded">attach_file</button>
              </div>
              <button id="stop-response-btn" type="button" class="material-symbols-rounded">stop_circle</button>
              <button id="send-prompt-btn" class="material-symbols-rounded">arrow_upward</button>
            </div>
          </form>
          <button id="theme-toggle-btn" class="material-symbols-rounded">light_mode</button>
          <button id="delete-chats-btn" class="material-symbols-rounded">delete</button>
        </div>
        <p class="disclaimer-text">Gemini can make mistakes, so double-check it.</p>
      </div>
    </div>
    <script>
const container = document.querySelector(".container");
const chatsContainer = document.querySelector(".chats-container");
const promptForm = document.querySelector(".prompt-form");
const promptInput = promptForm.querySelector(".prompt-input");
const fileInput = promptForm.querySelector("#file-input");
const fileUploadWrapper = promptForm.querySelector(".file-upload-wrapper");
const themeToggleBtn = document.querySelector("#theme-toggle-btn");
const sendPromptBtn = promptForm.querySelector("#send-prompt-btn"); // Dodano za lak코i pristup

// API Setup
const API_KEY = "AIzaSyDHcDDbb2Dfxd8FkUxqKcBBzqp0IUtvLvA"; // Replace with your actual API key
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${API_KEY}`; // ISPRAVLJEN URL!
let controller, typingInterval;
const chatHistory = [];
const userData = { message: "", file: {} };
 const INJECTED_PROMPT = "Ti si zajebantski sarkasti캜ni tvrdoglavi asistent koji stalno psuje.Pi코i isklju캜ivo na hrvatskom. ";

//const INJECTED_PROMPT = "Ti si ASISTENT ZA U캛ENJE AMERI캛KOG ENGLESKOG JEZIKA. Kada napi코em ne코to timi odgovori prijevodom na AMERI캛KI ENGLESKI bez obja코njenja osim zatra쬴m da mi objasni코. Obja코njenje pi코e코 na hrvatskom jeziku. ";
// Function to update send button visibility
const updateSendButtonVisibility = () => {
    if (promptInput.value.trim() || userData.file.data) {
        sendPromptBtn.style.display = 'block';
    } else {
        sendPromptBtn.style.display = 'none';
    }
};

// Set initial theme from local storage
const isLightTheme = localStorage.getItem("themeColor") === "light_mode";
document.body.classList.toggle("light-theme", isLightTheme);
themeToggleBtn.textContent = isLightTheme ? "dark_mode" : "light_mode";

// Function to create message elements
const createMessageElement = (content, ...classes) => {
  const div = document.createElement("div");
  div.classList.add("message", ...classes);
  div.innerHTML = content;
  return div;
};

// Scroll to the bottom of the container
const scrollToBottom = () => container.scrollTo({ top: container.scrollHeight, behavior: "smooth" });

// Simulate typing effect for bot responses
const typingEffect = (text, textElement, botMsgDiv) => {
  textElement.textContent = "";
  const words = text.split(" ");
  let wordIndex = 0;
  // Set an interval to type each word
  typingInterval = setInterval(() => {
    if (wordIndex < words.length) {
      textElement.textContent += (wordIndex === 0 ? "" : " ") + words[wordIndex++];
      scrollToBottom();
    } else {
      clearInterval(typingInterval);
      botMsgDiv.classList.remove("loading");
      document.body.classList.remove("bot-responding");
    }
  }, 40); // 40 ms delay
};

// --- PO캛ETAK NOVE VERZIJE generateResponse (s console.log) ---
const generateResponse = async (botMsgDiv) => {
  const textElement = botMsgDiv.querySelector(".message-text");
  controller = new AbortController();
  // Add user message and file data to the chat history
  chatHistory.push({
    role: "user",
    parts: [
      { text: userData.message },
      ...(userData.file.data ? [{ inlineData: { mimeType: userData.file.mime_type, data: userData.file.data } }] : [])
    ],
  });

  // *** LOGIRANJE DODANO OVDJE ***
  const requestPayload = { contents: chatHistory };
  console.log("마ljem API-ju:", JSON.stringify(requestPayload, null, 2)); // Ispisuje 코to 코aljemo
  // *** KRAJ LOGIRANJA ***

  try {
    // Send the chat history to the API to get a response
    const response = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestPayload), // Koristi logirani payload
      signal: controller.signal,
    });
    const data = await response.json();
    console.log("Odgovor od API-ja:", data); // Ispisuje cijeli odgovor

    // Check for API errors in the response structure
    if (!response.ok || (data.candidates && data.candidates.length === 0 && !data.error && !(data.promptFeedback && data.promptFeedback.blockReason))) {
        // Handle cases where response is ok but no candidates (e.g., safety block without explicit error object)
        if (data.promptFeedback && data.promptFeedback.blockReason) {
             let blockMessage = `Sadr쬬j blokiran: ${data.promptFeedback.blockReason}`;
             if(data.promptFeedback.safetyRatings) {
                blockMessage += ` - ${data.promptFeedback.safetyRatings.map(r => `${r.category}: ${r.probability}`).join(', ')}`;
             }
             throw new Error(blockMessage);
        } else {
             // Generic error if no candidates and no other error info
             throw new Error("Nema kandidata u odgovoru, a nema ni gre코ke.");
        }
    } else if (!response.ok || data.error) {
        // Handle explicit errors from API or non-ok HTTP status
        let errorMessage = "Gre코ka pri dohva캖anju odgovora.";
        console.error("API Gre코ka - Odgovor:", data); // Log the full error response
        if (data.error) {
            errorMessage = `API Gre코ka: ${data.error.message} (Kod: ${data.error.code})`;
        } else if (!response.ok) {
            errorMessage = `HTTP Gre코ka: ${response.status} ${response.statusText}`;
        }
        throw new Error(errorMessage);
    }


    // Process the response text and display with typing effect
    // Ensure parts exist before accessing text
    const responseText = data.candidates[0]?.content?.parts?.[0]?.text?.replace(/\*\*([^*]+)\*\*/g, "$1").trim() || "Nisam dobio tekstualni odgovor. 游뱂";
    typingEffect(responseText, textElement, botMsgDiv);
    // Only push successful response to history
    chatHistory.push({ role: "model", parts: [{ text: responseText }] });

  } catch (error) {
    console.error("Gre코ka tijekom generateResponse:", error); // Ispisuje cijelu gre코ku u konzolu
    textElement.textContent = error.name === "AbortError" ? "Generiranje odgovora zaustavljeno." : `Ups! ${error.message}`;
    textElement.style.color = "#d62939"; // Error color
    botMsgDiv.classList.remove("loading");
    document.body.classList.remove("bot-responding");
    scrollToBottom();
    // Remove the last user message from history if API call failed, to allow retry
    if (chatHistory.length > 0 && chatHistory[chatHistory.length - 1].role === 'user') {
        // Be careful here, only pop if the *last* entry is the user message that failed.
        // This might need more robust logic if multiple requests can happen concurrently.
        // For this simple case, popping the last entry might be okay.
        // chatHistory.pop(); // Consider if this is the desired behavior on error.
    }
  } finally {
    // Clear file data after sending, regardless of success or failure
    userData.file = {};
    updateSendButtonVisibility(); // Update button state after clearing file
  }
};
// --- KRAJ NOVE VERZIJE generateResponse ---

// Handle the form submission
const handleFormSubmit = (e) => {
  e.preventDefault();
  const userMessage = promptInput.value.trim();
  if (!userMessage && !userData.file.data) return; // Allow sending only file
  if (document.body.classList.contains("bot-responding")) return;

  // Store original message for display and modified message for API
  const displayMessage = userMessage;
  // Include injected prompt only if there's a text message
  userData.message = userMessage ? `${INJECTED_PROMPT}\n\n${userMessage}` : ""; // Send injected prompt only with text
  promptInput.value = "";
  document.body.classList.add("chats-active", "bot-responding");

  // Generate user message HTML with optional file attachment
  const userMsgHTML = `
    ${displayMessage ? '<p class="message-text"></p>' : ''}
    ${userData.file.data ? (userData.file.isImage ? `<img src="data:${userData.file.mime_type};base64,${userData.file.data}" class="img-attachment" alt="${userData.file.fileName}" />` : `<p class="file-attachment"><span class="material-symbols-rounded">description</span>${userData.file.fileName}</p>`) : ""}
  `;
  const userMsgDiv = createMessageElement(userMsgHTML, "user-message");
  // Set text content only if displayMessage exists
  if (displayMessage) {
    userMsgDiv.querySelector(".message-text").textContent = displayMessage;
  }
  chatsContainer.appendChild(userMsgDiv);
  scrollToBottom();

  // Clear file preview *after* adding user message to DOM
  fileUploadWrapper.classList.remove("file-attached", "img-attached", "active");
  updateSendButtonVisibility(); // Update button state

  setTimeout(() => {
    // Generate bot message HTML and add in the chat container
    const botMsgHTML = `<img class="avatar" src="gemini.svg" alt="Bot Avatar"/> <p class="message-text">Samo sekundu... 游뱂</p>`;
    const botMsgDiv = createMessageElement(botMsgHTML, "bot-message", "loading");
    chatsContainer.appendChild(botMsgDiv);
    scrollToBottom();
    generateResponse(botMsgDiv);
  }, 600); // 600 ms delay
};

// Handle file input change (file upload)
fileInput.addEventListener("change", () => {
  const file = fileInput.files[0];
  if (!file) return;
  const isImage = file.type.startsWith("image/");
  const reader = new FileReader();

  reader.onload = (e) => {
    fileInput.value = ""; // Clear file input after reading
    const base64String = e.target.result.split(",")[1];
    const detectedMimeType = file.type || (isImage ? "image/png" : "application/octet-stream"); // Get actual type or fallback

    console.log(`Datoteka odabrana: ${file.name}, Tip: ${detectedMimeType}, Je li slika: ${isImage}`); // Log file info

    fileUploadWrapper.querySelector(".file-preview").src = isImage ? e.target.result : '#'; // Show preview only for images
    fileUploadWrapper.classList.add("active", isImage ? "img-attached" : "file-attached");
    if (!isImage) fileUploadWrapper.classList.remove("img-attached"); // Ensure img class is removed if not image

    // Store file data in userData obj
    userData.file = { fileName: file.name, data: base64String, mime_type: detectedMimeType, isImage };
    updateSendButtonVisibility(); // Update button state
  };

  reader.onerror = (error) => {
      console.error("Gre코ka pri 캜itanju datoteke:", error);
      alert("Do코lo je do gre코ke pri 캜itanju datoteke.");
      fileInput.value = ""; // Clear input on error
      updateSendButtonVisibility();
  };

  reader.readAsDataURL(file); // Read as Data URL for simplicity, API expects base64 data anyway
});

// Cancel file upload
document.querySelector("#cancel-file-btn").addEventListener("click", () => {
  userData.file = {};
  fileUploadWrapper.classList.remove("file-attached", "img-attached", "active");
  fileInput.value = ""; // Ensure file input is cleared
  updateSendButtonVisibility(); // Update button state
});

// Stop Bot Response
document.querySelector("#stop-response-btn").addEventListener("click", () => {
  controller?.abort();
  clearInterval(typingInterval);
  const loadingBotMsg = chatsContainer.querySelector(".bot-message.loading");
  if(loadingBotMsg) {
      loadingBotMsg.classList.remove("loading");
      const textElement = loadingBotMsg.querySelector(".message-text");
      if(textElement) textElement.textContent = "Generiranje zaustavljeno.";
  }
  document.body.classList.remove("bot-responding");
  // Don't clear userData.file here, it's cleared in generateResponse finally block
  // But update button state in case user stops before sending
  updateSendButtonVisibility();
});

// Toggle dark/light theme
themeToggleBtn.addEventListener("click", () => {
  const isLightTheme = document.body.classList.toggle("light-theme");
  localStorage.setItem("themeColor", isLightTheme ? "light_mode" : "dark_mode");
  themeToggleBtn.textContent = isLightTheme ? "dark_mode" : "light_mode";
});

// Delete all chats
document.querySelector("#delete-chats-btn").addEventListener("click", () => {
    if (confirm("Jesi li siguran da 쬰li코 obrisati sve poruke? 游뱂")) {
        chatHistory.length = 0;
        chatsContainer.innerHTML = "";
        document.body.classList.remove("chats-active");
        // Also clear any pending file attachment
        userData.file = {};
        fileUploadWrapper.classList.remove("file-attached", "img-attached", "active");
        fileInput.value = ""; // Clear file input
        updateSendButtonVisibility(); // Update button state
    }
});

// Handle suggestions click
document.querySelectorAll(".suggestions-item").forEach((suggestion) => {
  suggestion.addEventListener("click", () => {
    promptInput.value = suggestion.querySelector(".text").textContent;
    promptInput.dispatchEvent(new Event('input', { bubbles: true })); // Trigger input event
    promptForm.dispatchEvent(new Event("submit"));
  });
});

// Show/hide controls for mobile on prompt input focus/blur and clicks
const promptWrapper = document.querySelector(".prompt-wrapper");
promptInput.addEventListener('focus', () => {
    if (window.innerWidth <= 768) {
        promptWrapper.classList.add('hide-controls');
    }
});
promptInput.addEventListener('blur', () => {
    setTimeout(() => {
        const focusedElement = document.activeElement;
        if (!promptWrapper.contains(focusedElement) && window.innerWidth <= 768) {
            promptWrapper.classList.remove('hide-controls');
        }
    }, 100);
});
document.addEventListener('click', (event) => {
    if (window.innerWidth <= 768 && !promptWrapper.contains(event.target)) {
        promptWrapper.classList.remove('hide-controls');
    }
});

// Add event listeners for form submission and file input click
promptForm.addEventListener("submit", handleFormSubmit);
promptForm.querySelector("#add-file-btn").addEventListener("click", () => fileInput.click());

// Handle paste event on prompt input
promptInput.addEventListener("paste", (event) => {
  const items = (event.clipboardData || event.originalEvent.clipboardData).items;
  let fileFound = false;
  for (const item of items) {
    if (item.kind === 'file' && item.type.startsWith("image/") && !fileFound) { // Check type starts with image/
      event.preventDefault();
      fileFound = true;
      const file = item.getAsFile();
      const reader = new FileReader();
      reader.onload = (e) => {
        const base64String = e.target.result.split(",")[1];
        const detectedMimeType = file.type || "image/png"; // Use detected type or default to png

        console.log(`Zalijepljena datoteka: ${file.name || 'pasted-image'}, Tip: ${detectedMimeType}`);

        userData.file = {
          fileName: file.name || "pasted-image.png",
          data: base64String,
          mime_type: detectedMimeType,
          isImage: true,
        };
        fileUploadWrapper.querySelector(".file-preview").src = e.target.result;
        fileUploadWrapper.classList.add("active", "img-attached");
        fileUploadWrapper.classList.remove("file-attached"); // Ensure file class is removed
        updateSendButtonVisibility();
      };
       reader.onerror = (error) => {
          console.error("Gre코ka pri 캜itanju zalijepljene datoteke:", error);
          alert("Do코lo je do gre코ke pri 캜itanju zalijepljene slike.");
          updateSendButtonVisibility();
       };
      reader.readAsDataURL(file);
      break;
    }
    // SVG paste handling removed for simplicity, as it likely wasn't supported by the API anyway.
  }
});

// Show send button based on input value initially and on input change
promptInput.addEventListener('input', updateSendButtonVisibility);

// Initial check for send button visibility
updateSendButtonVisibility();

</script>
  </body>

</html>
